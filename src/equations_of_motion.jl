
"""
    mee_equations_of_motion(u, p, t)

Compute the equations of motion for the modified equinoctial elements (MEEs), returning the
    time rate-of-chage of each MEE orbital element.

# Arguments
- `u::AbstractVector`: Modified equinoctial elements (p,f,g,h,k,L) state vector.
- `p::ForceModel`: The force model struct
- `t::AbstractFloat`: The current time in seconds past the initial epoch.

# Returns
- `du::SVector{6, Float64}`: Time rate-of-change of each MEE orbital element
"""
function mee_equations_of_motion(u, p, t, fm)
    # Get the perturbing accelerations
    ap = get_perturbing_accelerations(fm, u, t)

    # Get gravitational parameter
    mu = fm.mu

    # Compute requirements
    cosL    = cos(u[6])
    sinL    = sin(u[6])
    s2      = 1.0 + u[4]*u[4] + u[5]*u[5]
    κ       = u[4]*sinL - u[5]*cosL
    w       = 1.0 + u[2]*cosL + u[3]*sinL
    w_inv   = 1.0 / w
    wbp     = w / u[1]
    sqrtpmu = sqrt(u[1] / mu)

    # Compute equations of motion
    dp      = 2.0*u[1]*w_inv*sqrtpmu*ap[2]
    dfr     = sqrtpmu*ap[1]*sinL
    dft     = sqrtpmu*w_inv*((w + 1.0)*cosL + u[2])*ap[2]
    dfn     = -sqrtpmu*u[3]*w_inv*κ*ap[3]
    df      = dfr + dft + dfn
    dgr     = -sqrtpmu*ap[1]*cosL
    dgt     = sqrtpmu*w_inv*((w + 1.0)*sinL + u[3])*ap[2]
    dgn     = sqrtpmu*u[2]*w_inv*κ*ap[3]
    dg      = dgr + dgt + dgn
    dh      = 0.5*sqrtpmu*s2*w_inv*cosL*ap[3]
    dk      = 0.5*sqrtpmu*s2*w_inv*sinL*ap[3]
    dLfast  = sqrt(mu*u[1])*wbp*wbp
    dLn     = sqrtpmu*w_inv*κ*ap[3]
    dL      = dLfast + dLn

    # Return rates
    return SVector{6,Float64}(dp,df,dg,dh,dk,dL)
end

"""
    mee_equations_of_motion!(du, u, p, t)

Compute the equations of motion for the modified equinoctial elements (MEEs), modifying
    time rate-of-chage of each MEE orbital element `du` in-place.

# Arguments
- `du::AbstractVector`: Time rate-of-change of each MEE orbital element
- `u::AbstractVector`: Modified equinoctial elements (p,f,g,h,k,L) state vector.
- `p::ForceModel`: The force model struct
- `t::AbstractFloat`: The current time in seconds past the initial epoch.
"""
function mee_equations_of_motion!(du, u, p, t, fm)
    du .= mee_equations_of_motion(u, p, t, fm)
    return nothing
end

"""
    mee_equations_of_motion_jacobian(u, p, t)

Compute the Jacobian of the equations of motion for the modified equinoctial elements (MEEs).

# Arguments
- `u::AbstractVector`: Modified equinoctial elements (p,f,g,h,k,L) state vector.
- `p::ForceModel`: The force model struct
- `t::AbstractFloat`: The current time in seconds past the initial epoch.

# Returns
- `A::SMatrix{6,6,Float64}`: Jacobian of the equations of motion

# Notes
This function is partially generated by `src/code_gen/mee_partials_code.m`.
"""
function mee_equations_of_motion_jacobian(u, ps, t)
    # Get the perturbing accelerations and partials
    ap, dapdx = get_perturbing_accelerations_and_partials(ps, u, t)

    # Create appropriate variables for generated code
    p,f,g,h,k,L = u
    ar,at,an = ap
    dadx1_1 = dapdx[1,1]
    dadx1_2 = dapdx[1,2]
    dadx1_3 = dapdx[1,3]
    dadx1_4 = dapdx[1,4]
    dadx1_5 = dapdx[1,5]
    dadx1_6 = dapdx[1,6]
    dadx2_1 = dapdx[2,1]
    dadx2_2 = dapdx[2,2]
    dadx2_3 = dapdx[2,3]
    dadx2_4 = dapdx[2,4]
    dadx2_5 = dapdx[2,5]
    dadx2_6 = dapdx[2,6]
    dadx3_1 = dapdx[3,1]
    dadx3_2 = dapdx[3,2]
    dadx3_3 = dapdx[3,3]
    dadx3_4 = dapdx[3,4]
    dadx3_5 = dapdx[3,5]
    dadx3_6 = dapdx[3,6]

    # Get gravitational parameter
    mu = ps.mu

    # Start of machine generated code
    # See src/code_gen/mee_partials_code.m for the generator script
    t2 = cos(L);
    t3 = sin(L);
    t4 = f*h;
    t5 = g*k;
    t6 = mu*p;
    t7 = L*2.0;
    t8 = f*f;
    t9 = g*g;
    t10 = h*h;
    t11 = k*k;
    t19 = an*h*2.0;
    t20 = an*k*2.0;
    t21 = dadx3_1*p*2.0;
    t30 = 1.0/mu;
    t31 = 1.0/(p*p);
    t12 = t2*2.0;
    t13 = t2*t2;
    t14 = t2*t2*t2;
    t15 = sin(t7);
    t16 = t3*2.0;
    t17 = t3*t3;
    t18 = t3*t3*t3;
    t22 = an*t2;
    t23 = f*t2;
    t24 = h*t2;
    t25 = k*t2;
    t26 = an*t3;
    t27 = g*t3;
    t28 = h*t3;
    t29 = k*t3;
    t32 = dadx3_4*t10;
    t33 = dadx3_5*t10;
    t34 = dadx3_4*t11;
    t35 = dadx3_5*t11;
    t36 = at*g*t2;
    t40 = at*f*t3;
    t49 = p*t30;
    t52 = an+t21;
    t55 = sqrt(t6);
    t57 = t10+t11+1.0;
    t37 = dadx3_2*t23;
    t38 = dadx3_3*t23;
    t39 = k*t22;
    t41 = h*t26;
    t42 = dadx3_2*t27;
    t43 = dadx3_3*t27;
    t44 = t3*t23;
    t45 = t2*t27;
    t46 = -t22;
    t47 = -t26;
    t48 = -t28;
    t50 = f*t13;
    t51 = g*t17;
    t53 = -t14;
    t54 = -t18;
    t56 = -t36;
    t58 = (at*t15)/2.0;
    t59 = t23+t27+1.0;
    t63 = sqrt(t49);
    t69 = t4+t5+t24+t29;
    t70 = dadx3_4+t19+t32+t34;
    t71 = dadx3_5+t20+t33+t35;
    t60 = t2+t53;
    t61 = t3+t54;
    t62 = -t58;
    t64 = t25+t48;
    t65 = 1.0/t63;
    t66 = t59*t59;
    t67 = 1.0/t59;
    t72 = dadx3_3+t38+t43+t47;
    t73 = f+t12+t45+t50;
    t74 = dadx3_2+t37+t42+t46;
    t75 = g+t16+t44+t51;
    t68 = 1.0/t66;
    A011 = t63*t67*(at*3.0+dadx2_1*p*2.0);
    A012 = p*t63*t68*(dadx2_2-at*t2+dadx2_2*t23+dadx2_2*t27)*2.0;
    A013 = p*t63*t68*(dadx2_3-at*t3+dadx2_3*t23+dadx2_3*t27)*2.0;
    A014 = dadx2_4*p*t63*t67*2.0;
    A015 = dadx2_5*p*t63*t67*2.0;
    A016 = p*t63*t68*(dadx2_6+t40+t56+dadx2_6*t23+dadx2_6*t27)*2.0;
    A021 = (t30*t65*t67*(at*f+ar*t3+ar*t51+at*t12+at*t50-g*t41+g*t58+t5*t22+dadx2_1*f*p*2.0+(ar*f*t15)/2.0+dadx2_1*p*t2*4.0+dadx1_1*p*t16+dadx1_1*f*p*t15+dadx2_1*g*p*t15-dadx3_1*h*p*t27*2.0+dadx3_1*p*t5*t12+dadx1_1*p*t16*t27+dadx2_1*p*t12*t23))/2.0;
    A022 = dadx1_2*t3*t63+dadx2_2*t63*t67*t73+at*t3*t63*t68*(g+t3)+dadx3_2*g*t63*t64*t67+g*t46*t63*t64*t68;
    A023 = t63*t68*(t39-t40-t41+t62+dadx2_3*f+dadx1_3*t3+dadx2_3*t12+dadx2_3*t50*3.0-h*t43+dadx1_3*f*t15+dadx2_3*f*t27+dadx2_3*g*t15*(3.0/2.0)+an*k*t50-(an*t4*t15)/2.0+dadx2_3*t2*t8+dadx1_3*t9*t18+dadx3_3*t2*t5+dadx2_3*t8*t14+dadx1_3*t16*t27+dadx1_3*t8*t61+dadx3_3*t5*t50+dadx2_3*t9*t60+dadx1_3*f*g*t60*2.0+dadx2_3*f*g*t61*2.0-(dadx3_3*g*t4*t15)/2.0+(dadx3_3*g*t5*t15)/2.0-dadx3_3*h*t9*t17);
    A024 = t63*t67*(dadx2_4*f+dadx1_4*t3+dadx2_4*t12+dadx1_4*t51+dadx2_4*t50+g*t47+(dadx1_4*f*t15)/2.0+(dadx2_4*g*t15)/2.0-dadx3_4*h*t27+dadx3_4*t2*t5);
    A025 = t63*t67*(dadx2_5*f+dadx1_5*t3+dadx2_5*t12+dadx1_5*t51+dadx2_5*t50+g*t22+(dadx1_5*f*t15)/2.0+(dadx2_5*g*t15)/2.0-dadx3_5*h*t27+dadx3_5*t2*t5);
    A026 = ar*t2*t63+dadx1_6*t3*t63+dadx2_6*t63*t67*t73-at*t63*t68*(t16+t51*3.0+g*t13+g*t23*3.0+t9*t18+t8*t54-f*g*t14*2.0+f*t3*t12)-an*g*t63*t68*t69+dadx3_6*g*t63*t64*t67;
    A031 = (t30*t65*t67*(at*g*2.0-ar*t2*2.0-ar*t50*2.0+at*t3*4.0-f*t39*2.0+dadx2_1*g*p*4.0+at*f*t15-ar*g*t15-dadx1_1*p*t2*4.0+dadx2_1*p*t3*8.0-dadx1_1*p*t50*4.0+dadx2_1*p*t51*4.0+an*t4*t16+at*t16*t27+dadx2_1*f*p*t15*2.0-dadx1_1*g*p*t15*2.0-dadx3_1*k*p*t23*4.0+dadx3_1*p*t3*t4*4.0))/4.0;
    A032 = t63*t68*(-t39+t41+t56+t62+dadx2_2*g-dadx1_2*t2+dadx2_2*t16-dadx1_2*t50*2.0+dadx2_2*t51*3.0-k*t37+an*h*t51+dadx2_2*f*t15*(3.0/2.0)-dadx1_2*g*t15+dadx2_2*g*t23-(an*t5*t15)/2.0+dadx2_2*t3*t9+dadx3_2*t3*t4+dadx2_2*t9*t18+dadx1_2*t8*t53-dadx1_2*t9*t60+dadx3_2*t4*t51+dadx2_2*t8*t61-dadx1_2*f*g*t61*2.0+dadx2_2*f*g*t60*2.0+(dadx3_2*f*t4*t15)/2.0-(dadx3_2*f*t5*t15)/2.0-dadx3_2*k*t8*t13);
    A033 = -dadx1_3*t2*t63+dadx2_3*t63*t67*t75+at*t2*t63*t68*(f+t2)-dadx3_3*f*t63*t64*t67+f*t26*t63*t64*t68;
    A034 = t63*t67*(dadx2_4*g-dadx1_4*t2+dadx2_4*t16-dadx1_4*t50+dadx2_4*t51+f*t26+(dadx2_4*f*t15)/2.0-(dadx1_4*g*t15)/2.0-dadx3_4*k*t23+dadx3_4*t3*t4);
    A035 = t63*t67*(dadx2_5*g-dadx1_5*t2+dadx2_5*t16-dadx1_5*t50+dadx2_5*t51+f*t46+(dadx2_5*f*t15)/2.0-(dadx1_5*g*t15)/2.0-dadx3_5*k*t23+dadx3_5*t3*t4);
    A036 = ar*t3*t63-dadx1_6*t2*t63+dadx2_6*t63*t67*t75+at*t63*t68*(f+t12+f*t27+t8*t14+t12*t23+t12*t27+t9*t53+t12*t23*t27)+an*f*t63*t68*t69-dadx3_6*f*t63*t64*t67;
    A041 = (t2*t30*t52*t57*t65*t67)/4.0;
    A042 = (t2*t57*t63*t68*t74)/2.0;
    A043 = (t2*t57*t63*t68*t72)/2.0;
    A044 = (t2*t63*t67*t70)/2.0;
    A045 = (t2*t63*t67*t71)/2.0;
    A046 = (t57*t63*t68*(t47-an*g+dadx3_6*t2+dadx3_6*t45+dadx3_6*t50))/2.0;
    A051 = (t3*t30*t52*t57*t65*t67)/4.0;
    A052 = (t3*t57*t63*t68*t74)/2.0;
    A053 = (t3*t57*t63*t68*t72)/2.0;
    A054 = (t3*t63*t67*t70)/2.0;
    A055 = (t3*t63*t67*t71)/2.0;
    A056 = (t57*t63*t68*(t22+an*f+dadx3_6*g+dadx3_6*t3+dadx3_6*t44-dadx3_6*g*t13))/2.0;
    A061 = 1.0/(p*p*p)*t55*t66*-2.0-dadx3_1*t63*t64*t67+(mu*t31*t66)/(t55*2.0)-(an*t30*t64*t65*t67)/2.0;
    A062 = -dadx3_2*t63*t64*t67+t12*t31*t55*t59+t22*t63*t64*t68;
    A063 = -dadx3_3*t63*t64*t67+t16*t31*t55*t59+t26*t63*t64*t68;
    A064 = t63*t67*(t26-dadx3_4*t25+dadx3_4*t28);
    A065 = -t63*t67*(t22+dadx3_5*t25+dadx3_5*t48);
    A066 = an*t63*t68*t69-dadx3_6*t63*t64*t67-t31*t55*t59*(f*t3-g*t2)*2.0;
    return SMatrix{6,6}(
        A011,A021,A031,A041,A051,A061,
        A012,A022,A032,A042,A052,A062,
        A013,A023,A033,A043,A053,A063,
        A014,A024,A034,A044,A054,A064,
        A015,A025,A035,A045,A055,A065,
        A016,A026,A036,A046,A056,A066,
    )
end

"""
    mee_control_equations_of_motion(u, p, t, at)

Compute the equations of motion for the modified equinoctial elements (MEEs), returning the
    time rate-of-chage of each MEE orbital element.

# Arguments
- `u::AbstractVector`: Modified equinoctial elements (p,f,g,h,k,L) state vector.
- `p::ForceModel`: The force model struct
- `t::AbstractFloat`: The current time in seconds past the initial epoch.
- `at::AbstractVector`: The control acceleration vector

# Returns
- `du::SVector{6, Float64}`: Time rate-of-change of each MEE orbital element
"""
function mee_control_equations_of_motion(u, p, t, at)
    # Get the perturbing accelerations from celestial phenomenon
    apc = get_perturbing_accelerations(p, u, t)
    
    # Compute total perturbing acceleration
    ap  = SVector(apc[1] + at[1], apc[2] + at[2], apc[3] + at[3])

    # Get gravitational parameter
    mu = p.mu

    # Compute requirements
    cosL    = cos(u[6])
    sinL    = sin(u[6])
    s2      = 1.0 + u[4]*u[4] + u[5]*u[5]
    κ       = u[4]*sinL - u[5]*cosL
    w       = 1.0 + u[2]*cosL + u[3]*sinL
    w_inv   = 1.0 / w
    wbp     = w / u[1]
    sqrtpmu = sqrt(u[1] / mu)

    # Compute equations of motion
    dp      = 2.0*u[1]*w_inv*sqrtpmu*ap[2]
    dfr     = sqrtpmu*ap[1]*sinL
    dft     = sqrtpmu*w_inv*((w + 1.0)*cosL + u[2])*ap[2]
    dfn     = -sqrtpmu*u[3]*w_inv*κ*ap[3]
    df      = dfr + dft + dfn
    dgr     = -sqrtpmu*ap[1]*cosL
    dgt     = sqrtpmu*w_inv*((w + 1.0)*sinL + u[3])*ap[2]
    dgn     = sqrtpmu*u[2]*w_inv*κ*ap[3]
    dg      = dgr + dgt + dgn
    dh      = 0.5*sqrtpmu*s2*w_inv*cosL*ap[3]
    dk      = 0.5*sqrtpmu*s2*w_inv*sinL*ap[3]
    dLfast  = sqrt(mu*u[1])*wbp*wbp
    dLn     = sqrtpmu*w_inv*κ*ap[3]
    dL      = dLfast + dLn

    # Return rates
    return SVector(dp,df,dg,dh,dk,dL)
end

